import { Guid } from '@microsoft/sp-core-library';
import BaseDialog, { DialogState } from './BaseDialog';
import { IAlertOptions, IDialogShowOptions, IPromptOptions } from './IDialog';
import { ISecondaryDialogProvider } from './SecondaryDialogProvider';
/**
 * The internal interface for BaseDialog. We cast dialog objects to this interface to use the internal API.
 *
 * @internal
 */
export interface IInternalDialog {
    _state: DialogState;
    _requestId: Guid;
    _isActive: boolean;
    onAfterClose(): void;
    render(): void;
    _requestAck(requestId: Guid, isSecondary?: boolean): void;
    _setState(newState: DialogState): void;
    _render(container: HTMLElement): Promise<void>;
}
export declare function _getInternalDialogApi(dialog: BaseDialog): IInternalDialog;
/**
 * @internal
 */
export default class DialogManager {
    private static _instance;
    private static readonly _logSource;
    private _container;
    private _mainDialogDiv;
    private _childDialogDiv;
    private _requests;
    private _mainUiComponent;
    private _childUiComponent;
    /**
     * Get the singleton instance of DialogManager. It looks for a singleton instance of DialogManagerConfiguration
     * to initialize and throws if it is not found. The configuration instance is set on the page by the application.
     */
    static readonly instance: DialogManager;
    /**
     * {@inheritDoc Dialog.alert}
     */
    alert(message: string, options?: IAlertOptions): Promise<void>;
    /**
     * {@inheritDoc Dialog.prompt}
     */
    prompt(message: string, options?: IPromptOptions): Promise<string>;
    /**
     * If the manager has an open dialog
     */
    readonly isShowingDialog: boolean;
    /**
     * Add a request to show a dialog. Requests are handled on FIFO basis.
     *
     * @returns A void promise that resolves when the dialog is closed, or rejects if the request is rejected or aborted.
     *
     * @param dialog - The dialog to show
     * @param options - A callback that checks if the dialog still wants to be shown. Because there might be a delay
     * until the request is approved, the caller might not want to show the dialog anymore by the time it's approved.
     * This callback is called before showing the dialog and if returns true, the request is aborted.
     */
    show(dialog: BaseDialog, options?: IDialogShowOptions): Promise<void>;
    createSecondaryDialogProvider(ownerRequestId: Guid): ISecondaryDialogProvider;
    /**
     * This method is used by secondary dialog manager to show a secondary dialog.
     */
    _showSecondary(dialog: BaseDialog, ownerRequestId: Guid, options?: IDialogShowOptions): Promise<void>;
    /**
     * Abort the request for the given dialog.
     * Note: Active dialogs cannot be aborted because they are alreay approved.
     */
    _abort(dialog: BaseDialog): void;
    /**
     * This is called when the dialog rejects is onOpen promise, which is a special case that we treat like abort but
     * we also have to close the modal and NOT call onAfterClose().
     */
    _rejectOnOpen(dialog: BaseDialog): void;
    /**
     * Close the given dialog
     */
    _close(dialog: BaseDialog): Promise<void>;
    private constructor();
    private readonly _activeDialogs;
    private readonly _pendingRequests;
    private readonly _hasHiddenDialog;
    private readonly _currentlyOpenDialogRequest;
    private readonly _config;
    /**
     * Process the request on top of the queue.
     */
    private _processNextRequest;
    private _removeRequest;
    private _hide;
    private _unhide;
    private _getUiComponent;
    private _open;
    /**
     * SecondaryDialogManager passes the request id for the open (primary) dialog. This method checks if that request id
     * is indeed for the currently open dialog to make sure the secondary dialog has permission to show.
     */
    private _hasPermissionToShow;
    private _getRequestById;
}
//# sourceMappingURL=DialogManager.d.ts.map