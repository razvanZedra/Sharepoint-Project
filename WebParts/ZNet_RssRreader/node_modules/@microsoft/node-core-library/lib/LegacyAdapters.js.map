{"version":3,"file":"LegacyAdapters.js","sourceRoot":"","sources":["../src/LegacyAdapters.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAI3D;;;;GAIG;AACH;IAgBS,MAAM,CAAC,wBAAwB,CACpC,EAIS,EACT,IAAY,EACZ,IAAY;QAEZ,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAkC,EAAE,MAA8B;YACpF,MAAM,EAAE,GAA8B,CAAC,KAAa,EAAE,MAAe;gBACnE,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACV,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC3C,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,OAAO,CAAC,MAAM,CAAC,CAAC;gBAClB,CAAC;YACH,CAAC,CAAC;YAEF,IAAI,CAAC;gBACH,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAU,CAAC,CAAC,CAAC;oBAC9C,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;gBACrB,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,SAAU,CAAC,CAAC,CAAC;oBAC/B,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;gBACf,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,EAAE,CAAC,EAAE,CAAC,CAAC;gBACT,CAAC;YACH,CAAC;YAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACX,MAAM,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,UAAU,CAAC,KAA2B;QAClD,EAAE,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC;YAC3B,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,WAAW,GAAU,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;YAC1D,WAAmB,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC,6BAA6B;YACrE,MAAM,CAAC,WAAW,CAAC;QACrB,CAAC;IACH,CAAC;CACF;AA9DD,wCA8DC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nexport type callback<TResult, TError> = (error: TError, result: TResult) => void;\r\n\r\n/**\r\n * Helper functions used when interacting with APIs that do not follow modern coding practices.\r\n *\r\n * @beta\r\n */\r\nexport class LegacyAdapters {\r\n  /**\r\n   * This function wraps a function with a callback in a promise.\r\n   */\r\n  public static convertCallbackToPromise<TResult, TError>(\r\n    fn: (cb: callback<TResult, TError>) => void\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1>(\r\n    fn: (arg1: TArg1, cb: callback<TResult, TError>) => void,\r\n    arg1: TArg1\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2>(\r\n    fn: (arg1: TArg1, arg2: TArg2, cb: callback<TResult, TError>) => void,\r\n    arg1: TArg1,\r\n    arg2: TArg2\r\n  ): Promise<TResult>;\r\n  public static convertCallbackToPromise<TResult, TError, TArg1, TArg2>(\r\n    fn: (\r\n      a: TArg1 | callback<TResult, TError>,\r\n      b?: TArg2 | callback<TResult, TError>,\r\n      c?: TArg2 | callback<TResult, TError>\r\n    ) => void,\r\n    arg1?: TArg1,\r\n    arg2?: TArg2\r\n  ): Promise<TResult> {\r\n    return new Promise((resolve: (result: TResult) => void, reject: (error: Error) => void) => {\r\n      const cb: callback<TResult, TError> = (error: TError, result: TResult) => {\r\n        if (error) {\r\n          reject(LegacyAdapters.scrubError(error));\r\n        } else {\r\n          resolve(result);\r\n        }\r\n      };\r\n\r\n      try {\r\n        if (arg1 !== undefined && arg2 !== undefined ) {\r\n          fn(arg1, arg2, cb);\r\n        } else if (arg1 !== undefined ) {\r\n          fn(arg1, cb);\r\n        } else {\r\n          fn(cb);\r\n        }\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Normalizes an object into an `Error` object.\r\n   */\r\n  public static scrubError(error: Error | string | any): Error { // tslint:disable-line:no-any\r\n    if (error instanceof Error) {\r\n      return error;\r\n    } else if (typeof error === 'string') {\r\n      return new Error(error);\r\n    } else {\r\n      const errorObject: Error = new Error('An error occurred.');\r\n      (errorObject as any).errorData = error; // tslint:disable-line:no-any\r\n      return errorObject;\r\n    }\r\n  }\r\n}\r\n"]}