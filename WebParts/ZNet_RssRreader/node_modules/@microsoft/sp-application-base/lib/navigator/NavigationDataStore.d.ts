import { _IPreloadedData } from '@microsoft/sp-loader';
import { INavigationProperties } from './INavigationResult';
import { INavigationDataResponse } from './INavigationDataResponse';
/**
 * Represents the contract of a navigation data store item
 *
 * @internal
 */
export interface INavigationDataStoreItem {
    /**
     * The navigation source url
     */
    url: string;
    /**
     * The preloaded navigation data
     */
    preloadedData: _IPreloadedData;
    /**
     * The prefetched application data
     */
    prefetchedData: any;
    /**
     * The data fetch time stamp
     */
    fetchedTimeStamp: number;
}
/**
 * Represents the contract of a Navigation data store heap
 *
 * @internal
 */
export interface INavigationDataStoreHeap<TItem extends INavigationDataStoreItem> {
    items: Array<TItem>;
    size: number;
}
/**
 * Represents the contract of a navigation data cache store
 *
 * @internal
 */
export interface INavigationDataStore<TItem extends INavigationDataStoreItem> {
    /**
     * Gets the store id
     */
    id: string;
    /**
     * Gets the store item collection
     */
    items: Array<TItem>;
    /**
     * Gets an item associated with a given key
     * @param url - The URL
     * @param props - Optional Navigation property bag
     *
     * @returns The Promise associated with the navigation data response.
     */
    getData(url: string, props?: INavigationProperties): Promise<INavigationDataResponse>;
}
/**
 * Navigation Data Store that stores navigation data items while enforcing
 * constraints to ensure optimal use of resources
 *
 * @internal
 */
export default class NavigationDataStore<TItem extends INavigationDataStoreItem> implements INavigationDataStore<TItem> {
    private static readonly refreshThresholdMs;
    private static readonly maxStoreSize;
    private _id;
    private _executor;
    private _dataValidator;
    private _store;
    private _refreshThreshold;
    private _maxStoreSize;
    private static _leftChild(index);
    private static _rightChild(index);
    private static _parent(index);
    private static _swap<T>(items, leftIdx, rightIdx);
    private static _initStore<T>(id, maxSize);
    private static _updateStore<T>(id, items);
    private static _generatePrefetchHeaders();
    constructor(id: string, executor: <T>(url: string, headers?: Headers) => Promise<T>, validator: (preloadedData: _IPreloadedData) => void, refreshThresholdMs?: number, maxStoreSize?: number);
    /**
     * Gets the Store Id
     */
    readonly id: string;
    /**
     * Gets all the store items
     */
    readonly items: Array<TItem>;
    /**
     * Gets the item associated with a key.
     *
     * @remarks
     * If the Item exists in the store and is still valid then returns from the store,
     * else relies on the executor to fetch the item from the store and upserts it accordingly
     *
     * @param url - The url corresponding to the item
     * @param props - Optional Navigation property bag
     *
     * @returns The Promise associated with the navigation data response.
     */
    getData(url: string, props?: INavigationProperties): Promise<INavigationDataResponse>;
    private _fetchData(url, props?, cachedItem?, cachedItemIdx?);
    private _heapify(index);
    private _extractMin();
    private _reduceKey(index, item);
    private _insert(item);
    private _buildMinHeap(items);
    private _findItem(url);
}
