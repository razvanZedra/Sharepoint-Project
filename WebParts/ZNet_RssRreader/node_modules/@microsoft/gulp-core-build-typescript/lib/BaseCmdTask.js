"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const path = require("path");
const os = require("os");
const node_core_library_1 = require("@microsoft/node-core-library");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
/**
 * This base task provides support for finding and then executing a binary in a node package.
 *
 * @alpha
 */
class BaseCmdTask extends gulp_core_build_1.GulpTask {
    constructor(name, options) {
        super(name, options.initialTaskConfig);
        this._packageName = options.packageName;
        this._packageBinPath = options.packageBinPath;
    }
    static get _nodePath() {
        if (!BaseCmdTask.__nodePath) {
            try {
                if (os.platform() === 'win32') {
                    // We're on Windows
                    const whereOutput = childProcess.execSync('where node', { stdio: [] }).toString();
                    const lines = whereOutput.split(os.EOL).filter((line) => !!line);
                    // take the first result, see https://github.com/Microsoft/web-build-tools/issues/759
                    BaseCmdTask.__nodePath = lines[0];
                }
                else {
                    // We aren't on Windows - assume we're on *NIX or Darwin
                    BaseCmdTask.__nodePath = childProcess.execSync('which node', { stdio: [] }).toString();
                }
            }
            catch (e) {
                return undefined;
            }
            BaseCmdTask.__nodePath = BaseCmdTask.__nodePath.trim();
            if (!node_core_library_1.FileSystem.exists(BaseCmdTask.__nodePath)) {
                return undefined;
            }
        }
        return BaseCmdTask.__nodePath;
    }
    static getPackagePath(packageName) {
        const packageJsonPath = BaseCmdTask._getPackageJsonPath(packageName);
        return packageJsonPath ? path.dirname(packageJsonPath) : undefined;
    }
    static _getPackageJsonPath(packageName) {
        const lookup = new node_core_library_1.PackageJsonLookup();
        const mainEntryPath = require.resolve(packageName);
        return lookup.tryGetPackageJsonFilePathFor(mainEntryPath);
    }
    executeTask(gulp, completeCallback) {
        let packageJsonPath = BaseCmdTask._getPackageJsonPath(this._packageName);
        if (this.taskConfig.overridePackagePath) {
            // The package version is being overridden
            if (!node_core_library_1.FileSystem.exists(this.taskConfig.overridePackagePath)) {
                completeCallback(`The specified ${this._packageName} path (${this.taskConfig.overridePackagePath}) does not ` +
                    'exist');
                return;
            }
            // try to get the package at the override
            const newPackageAbsPath = path.resolve(this.taskConfig.overridePackagePath);
            const newPackageJsonPath = BaseCmdTask._getPackageJsonPath(newPackageAbsPath);
            if (newPackageJsonPath) {
                // if we managed to get a package here, we can use its package.json instead
                packageJsonPath = newPackageJsonPath;
            }
            else {
                this.logWarning(`Could not locate a package.json for ${this._packageName} at ${this.taskConfig.overridePackagePath}.` +
                    '  Attempting to use the package.json for the default package instead.');
            }
        }
        if (!packageJsonPath) {
            completeCallback(`Unable to find the package.json file for ${this._packageName}.`);
            return;
        }
        const binaryPackagePath = path.dirname(packageJsonPath);
        // Print the version
        const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
        this.log(`${this._packageName} version: ${packageJson.version}`);
        const binaryPath = path.resolve(binaryPackagePath, this._packageBinPath);
        if (!node_core_library_1.FileSystem.exists(binaryPath)) {
            completeCallback(`The binary is missing. This indicates that ${this._packageName} is not ` +
                'installed correctly.');
            return;
        }
        return new Promise((resolve, reject) => {
            const nodePath = BaseCmdTask._nodePath;
            if (!nodePath) {
                reject(new Error('Unable to find node executable'));
                return;
            }
            // Invoke the tool and watch for log messages
            const spawnResult = childProcess.spawn(nodePath, [binaryPath, ...this._getArgs()], {
                cwd: this._buildDirectory,
                env: process.env,
                stdio: 'pipe'
            });
            spawnResult.stdout.on('data', this._onData.bind(this));
            spawnResult.stderr.on('data', (data) => {
                this._errorHasBeenLogged = true;
                this._onError(data);
            });
            spawnResult.on('close', (code) => this._onClose(code, this._errorHasBeenLogged, resolve, reject));
        });
    }
    get _buildDirectory() {
        return this.taskConfig.buildDirectory || this.buildConfig.rootPath;
    }
    _onData(data) {
        this.log(data.toString().trim());
    }
    _onError(data) {
        this.logError(data.toString().trim());
    }
    _onClose(code, hasErrors, resolve, reject) {
        if (code !== 0 || hasErrors) {
            reject(new Error(`exited with code ${code}`));
        }
        else {
            resolve();
        }
    }
    _getArgs() {
        return this.taskConfig.customArgs || [];
    }
}
exports.BaseCmdTask = BaseCmdTask;
//# sourceMappingURL=BaseCmdTask.js.map